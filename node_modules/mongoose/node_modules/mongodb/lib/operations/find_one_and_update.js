'use strict';

<<<<<<< HEAD
=======
const MongoError = require('../core').MongoError;
>>>>>>> f6c82f61ab61d7a624b609f8e9ccdad7db0db275
const FindAndModifyOperation = require('./find_and_modify');
const hasAtomicOperators = require('../utils').hasAtomicOperators;

class FindOneAndUpdateOperation extends FindAndModifyOperation {
  constructor(collection, filter, update, options) {
<<<<<<< HEAD
=======
    if ('returnDocument' in options && 'returnOriginal' in options) {
      throw new MongoError(
        'findOneAndUpdate option returnOriginal is deprecated in favor of returnDocument and cannot be combined'
      );
    }
>>>>>>> f6c82f61ab61d7a624b609f8e9ccdad7db0db275
    // Final options
    const finalOptions = Object.assign({}, options);
    finalOptions.fields = options.projection;
    finalOptions.update = true;
<<<<<<< HEAD
    finalOptions.new =
      typeof options.returnOriginal === 'boolean' ? !options.returnOriginal : false;
    finalOptions.upsert = typeof options.upsert === 'boolean' ? options.upsert : false;
=======
    finalOptions.new = options.returnDocument === 'after' || options.returnOriginal === false;
    finalOptions.upsert = options.upsert === true;
>>>>>>> f6c82f61ab61d7a624b609f8e9ccdad7db0db275

    if (filter == null || typeof filter !== 'object') {
      throw new TypeError('Filter parameter must be an object');
    }

    if (update == null || typeof update !== 'object') {
      throw new TypeError('Update parameter must be an object');
    }

    if (!hasAtomicOperators(update)) {
      throw new TypeError('Update document requires atomic operators');
    }

    super(collection, filter, finalOptions.sort, update, finalOptions);
  }
}

module.exports = FindOneAndUpdateOperation;
